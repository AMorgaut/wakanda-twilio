/** * This shared worker is maintained while the service is running (or even in pause) **/var	/*	HTTP_PARAMS_VOICE,	HTTP_PARAMS_SMS,	HTTP_PARAMS_LOCALISATION,	*/	PATH_BASE,	PATH_HTTP_REQUEST_HANDLER,	PATH_LISTENER_WORKER,	/*	call,	sms,	*/	liveTwimlScripts,	listeners;/*HTTP_PARAMS_VOICE = ['CallSid', 'AccountSid', 'From', 'To', 'CallStatus', 'ApiVersion', 'Direction', 'ForwardedFrom', 'CallerName'];HTTP_PARAMS_SMS = ['SmsSid', 'AccountSid', 'From', 'To', 'Body'];HTTP_PARAMS_LOCALISATION = ['FromCity', 'FromState', 'FromZip', 'FromCountry', 'ToCity', 'ToState', 'ToZip', 'ToCountry'];*/PATH_BASE = File(module.id + '.js').parent.path;PATH_HTTP_REQUEST_HANDLER = PATH_BASE + 'httpRequestHandler.js';PATH_LISTENER_WORKER = PATH_BASE + 'listenerWorker.js';/*sms = require('wakanda-twilio/sms');call = require('wakanda-twilio/call');*/liveTwimlScripts = {};listeners = {};function dispatchEvent(data, httpRequestHandlerPort) {	var		uriListeners,		messageData,		responseReceived;	uriListeners = listeners[data.uri];		if (uriListeners) {		responseReceived = false;		uriListeners.forEach(			function fireEvent(portOrlistenerPath) {				var					listenerWorker;				if (typeof portOrlistenerPath === 'string') {					listenerWorker = new Worker(PATH_LISTENER_WORKER);					data.listenerPath = portOrlistenerPath;					listenerWorker.postMessage(data);					listenerWorker.onmessage = function onListenerWorkerMessage(message) {						if (responseReceived) {							console.log('message from', listenerPath, 'ignored, a listener already returned a response for the HTTP handler');						} else {							httpRequestHandlerPort.postMessage(message.data);							httpRequestHandlerPort.close();							console.log('message from', listenerPath, 'returned to the HTTP client');							responseReceived = true;						}					}				} else {					portOrlistenerPath.postMessage(data);					portOrlistenerPath.onmessage = function (message) {						httpRequestHandlerPort.postMessage(message.data);						httpRequestHandlerPort.close();					}				}			}		);	} else {		// TODO: define if it should be 404 (Not Found) or 204 (No Content)		messageData = {			status: 404 // Not Found		}		httpRequestHandlerPort.postMessage(messageData);		httpRequestHandlerPort.close();	}}self.onconnect = function onconnect(connectEvent) {	var		port;	port = connectEvent.ports[0];	port.onmessage = function onmessage(messageEvent) {		var			data,			eventListeners;		data = messageEvent.data;				switch (data.type) {		case 'httprequest':			if (data.live) {				port.postMessage(liveTwimlScripts[data.twimlId]);				delete liveTwimlScripts[data.twimlId];			} else {				dispatchEvent(data, port);			}			break;		case 'listen':			eventListeners = listeners[data.uri];			if (!eventListeners) {				listeners[data.uri] = [];				eventListeners = listeners[data.uri];				addHttpRequestHandler(data.uri, PATH_HTTP_REQUEST_HANDLER, 'Twilio_handleRequest');			}			eventListeners.push(data.direct ? port : data.listenerPath);			break;		case 'unlisten':			eventListeners = listeners[data.uri];			if (eventListeners && eventListeners.length) {				eventListeners.splice(eventListeners.indexof(data.direct ? port : data.listenerPath), 1);			}			if (eventListeners.length === 0) {				delete listeners[data.uri];				removeHttpRequestHandler(data.uri, PATH_HTTP_REQUEST_HANDLER, 'Twilio_handleRequest');			}			break;		/*		case 'start':			addHttpRequestHandler(				'^' + path,				'wakanda-twilio/core/httpRequestHandler',				'Twilio_handleRequest'			);			break;		*/		default:			console.warn('unsupported data.type', data);		}			};};